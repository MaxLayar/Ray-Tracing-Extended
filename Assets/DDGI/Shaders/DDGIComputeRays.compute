// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel main
#pragma multi_compile_local __ DEBUG_MODE


#include <UnityPBSLighting.cginc>
#include <UnityStandardBRDF.cginc>

#include "RayTraceUtilities.cginc"
#include "RandomUtilities.cginc"
#include "SampleIrradianceField.cginc"

uint2 surfelSize;

StructuredBuffer<float3> ProbesPositions;

RWStructuredBuffer<float4> rayDirections;
RWStructuredBuffer<float4> rayHitLocations;
RWStructuredBuffer<float4> rayHitRadiance;
RWStructuredBuffer<float4> rayHitNormals;
RWStructuredBuffer<float4> rayOrigins;

#ifdef DEBUG_MODE
RWTexture2D<float4> debugTex;
#endif

float4x4 randomOrientation;
float4 sunColor;
float3 sunDirection;

//DEBUG
int Frame;


float3 Shade(SurfaceOutputStandard s, float3 viewVec) {
    // Fetch Normal Map from texture
    float3 normalMap = s.Normal;
  
    // World normal (assuming normals are already in worldspace)
    float3 worldNormal = normalMap;
  
    // View direction (camera to the current pixel)
    float3 viewDir = normalize(viewVec);
  
    // Light direction (assuming a directional light, adjust for your light source)
    float3 lightDir = normalize(sunDirection);
  
    // Half vector (used in specular reflection calculation)
    float3 halfVec = normalize(viewDir + lightDir);
  
    // Lambertian reflection (Diffuse reflection)
    float3 diffuseReflection = s.Albedo.rgb / M_PI;
  
    // Cook-Torrance BRDF with GGX microfacet model (Specular reflection)
    float roughness = s.Smoothness * s.Smoothness;
    float roughness2 = roughness * roughness;
  
    float NdotL = saturate(dot(worldNormal, lightDir));
    float NdotV = saturate(dot(worldNormal, viewDir));
    float NdotH = saturate(dot(worldNormal, halfVec));
    float VdotH = saturate(dot(viewDir, halfVec));
  
    float D = roughness2 / (M_PI * pow(NdotH * NdotH * (roughness2 - 1) + 1, 2));
    float G = min(1, min(2 * NdotH * min(NdotV, NdotL) / VdotH, 2 * NdotH * min(NdotV, NdotL) / NdotH));
    float F = 0.04 + (1 - 0.04) * pow(1 - VdotH, 5);
  
    float3 specularReflection = (D * G * F) / (4 * NdotL * NdotV);
  
    // Occlusion factor (reducing specular reflections in occluded areas)
    float occlusion = s.Occlusion;
    float3 specularReflectionOcclud = specularReflection * occlusion;
  
    // Final color (Combining diffuse and specular reflections with occlusion)
    return lerp(diffuseReflection, specularReflectionOcclud, s.Metallic) * (1 - occlusion) + s.Emission.rgb;
}  

[numthreads(8,8,1)]
void main(uint3 id : SV_DispatchThreadID) 
{   
    uint2 texelPos = uint2(id.x, id.y);

    // uint2 dim;
    // rayDirections.GetDimensions(dim.x, dim.y);    
    // if(texelPos.x >= dim.x || texelPos.y >= dim.y) return;

    Ray ray;
    ray.direction = normalize(float3(mul(sphericalFibonacci((float) texelPos.x, (float) NumRaysPerProbe), (float3x3) randomOrientation))); //rayId = texelPos.x
    ray.origin = ProbesPositions[texelPos.y]; //probeId = texelPos.y
    ray.tMin = 0.01;
    ray.tMax = 1000.0;

    HitInfo info;
    float4 allLight = float4(0,0,0,0);
    if (TraceRay(ray, info))
    {
        float3 viewVec = normalize(_WorldSpaceCameraPos - info.hitPoint);
        float4 indirectL = float4(sampleIrradiance(DDGIVolumes, info.hitPoint, info.normal*.02+viewVec*.08, info.normal, _WorldSpaceCameraPos, false, false, -1), 1);
            //sampleIrradiance(DDGIVolumes[0], info.hitPoint, info.normal, DDGIVolumes[0].energyConservation, viewVec), 1);
        
        HitInfo shadowHit;
        Ray shadowRay;
        shadowRay.direction = -sunDirection;
        shadowRay.origin = info.hitPoint + (info.normal * DDGIVolumes[0].selfShadowBias);
        shadowRay.tMin = 0.01;
        shadowRay.tMax = 1000.0;
        int lit = !TraceRay(shadowRay, shadowHit); //sHit ? 0 : 1;
        float4 directL = sunColor * max(dot(info.normal, -sunDirection), 0) * lit;
        allLight = directL + indirectL;

        SurfaceOutputStandard s;
        s.Albedo = info.material.colour.xyz; // base (diffuse or specular) color
        s.Normal = info.normal;
        s.Emission = info.material.emissionColour * info.material.emissionStrength;
        s.Metallic = info.material.specularProbability; // 0=non-metal, 1=metal
        s.Smoothness = info.material.smoothness; // 0=rough, 1=smooth
        s.Occlusion = 0; // occlusion (default 1)
        s.Alpha = info.material.colour.w; // alpha for transparencies

        allLight *= float4(Shade(s, viewVec), s.Alpha); 
    }
    
    Write(rayDirections, texelPos, surfelSize, float4(ray.direction, info.dst));
    Write(rayHitLocations, texelPos, surfelSize, float4(info.hitPoint, info.dst) * info.didHit);
    Write(rayHitRadiance, texelPos, surfelSize, allLight);
    Write(rayHitNormals, texelPos, surfelSize, float4(info.normal,0) * info.didHit);
    Write(rayOrigins, texelPos, surfelSize, float4(ray.origin, info.dst));

    #ifdef DEBUG_MODE
    debugTex[texelPos] = allLight;
    #endif
}