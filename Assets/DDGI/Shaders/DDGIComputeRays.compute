// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel main
#pragma multi_compile_local __ DEBUG_MODE

#include <UnityPBSLighting.cginc>
#include <UnityStandardBRDF.cginc>

#include "SampleIrradianceField.cginc"
#include "RayTraceUtilities.cginc"
#include "RandomUtilities.cginc"

uint2 surfelSize;

StructuredBuffer<float3> ProbesPositions;

RWStructuredBuffer<float4> rayDirections;
RWStructuredBuffer<float4> rayHitLocations;
RWStructuredBuffer<float4> rayHitRadiance;
RWStructuredBuffer<float4> rayHitNormals;
RWStructuredBuffer<float4> rayOrigins;

#ifdef DEBUG_MODE
RWTexture2D<float4> debugTex;
#endif

float4x4 randomOrientation;
float4 sunColor;
float3 sunDirection;

//DEBUG
int Frame;

[numthreads(8,8,1)]
void main(uint3 id : SV_DispatchThreadID) 
{   
    uint2 texelPos = uint2(id.x, id.y);

    // uint2 dim;
    // rayDirections.GetDimensions(dim.x, dim.y);    
    // if(texelPos.x >= dim.x || texelPos.y >= dim.y) return;

    Ray ray;
    ray.direction = normalize(float3(mul(sphericalFibonacci((float) texelPos.x, (float) NumRaysPerProbe), (float3x3) randomOrientation))); //rayId = texelPos.x
    ray.origin = ProbesPositions[texelPos.y]; //probeId = texelPos.y
    ray.tMin = 0.01;
    ray.tMax = 1000.0;

    HitInfo info;
    float4 allLight = float4(0,0,0,0);
    if (TraceRay(ray, info))
    {
        float3 viewVec = normalize(_WorldSpaceCameraPos - info.hitPoint);
        allLight = ComputeShadingAt(info, viewVec, sunDirection, sunColor, 1000.0, false);
    }
    
    Write(rayDirections, texelPos, surfelSize, float4(ray.direction, info.dst));
    Write(rayHitLocations, texelPos, surfelSize, float4(info.hitPoint, info.dst) * info.didHit);
    Write(rayHitRadiance, texelPos, surfelSize, allLight);
    Write(rayHitNormals, texelPos, surfelSize, float4(info.normal,0) * info.didHit);
    Write(rayOrigins, texelPos, surfelSize, float4(ray.origin, info.dst));

    #ifdef DEBUG_MODE
    debugTex[texelPos] = allLight;
    #endif
}