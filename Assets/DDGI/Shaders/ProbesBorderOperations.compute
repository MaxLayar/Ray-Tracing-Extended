#pragma kernel mainWriteOnesToBorder
#pragma kernel mainDuplicateProbeEdges

#pragma multi_compile_local __ DEBUG_MODE

#include "ShaderUtilities.cginc"

RWStructuredBuffer<float4> probesBuffer;
uint2 probesBufferSize;

float PROBE_SIDE_LENGTH;

#ifdef DEBUG_MODE
RWTexture2D<float4> debugTex;
#endif


bool isAtProbeBorder(uint2 pos, out bool isAtProbeX, out bool isAtProbeY)
{
    int gap = PROBE_SIDE_LENGTH;
    isAtProbeX = (pos.x % gap == 0) || ((pos.x % gap) == gap - 1);
    isAtProbeY = (pos.y % gap == 0) || ((pos.y % gap) == gap - 1);
    return isAtProbeX || isAtProbeY;
}


// uint mirrored(uint pos)
// {
//     uint gap = 2 + PROBE_SIDE_LENGTH;
//     uint probe = (pos-2) / gap;
//     uint startPoint = (probe * gap)+2;
//     float midPoint = startPoint + (PROBE_SIDE_LENGTH-1) / 2.0;
//     float dst = midPoint - pos;
//     return pos + dst * 2;
// }


/*
XXX|XXX
Xxx|xxX
Xxx|xxX
Xxx|xxX
Xxx|xxX
XXX|XXX <-- on this half?
^-- or on this half? 
*/
int leftOrRight(int pos)
{
    pos = pos - 1;
    uint probeWithBorderSize = 2 + PROBE_SIDE_LENGTH;
    uint posInProbe = pos % probeWithBorderSize;
    uint middle = probeWithBorderSize / 2;
    return posInProbe < middle ? 1 : -1;
}

int mirrored(int pos)
{
    pos = pos - 1;
    int probeWithBorderSize = 2 + PROBE_SIDE_LENGTH;
    int posInProbe = int(pos) % probeWithBorderSize;
    int probe = int(pos) / probeWithBorderSize;
    int probeStart = (probe * probeWithBorderSize) + 1;
    int middle = probeWithBorderSize / 2;
    int dstToMiddle = middle - posInProbe;
    return probeStart + middle + dstToMiddle - 1;
}

[numthreads(8,8,1)]
void mainWriteOnesToBorder(uint3 id : SV_DispatchThreadID) 
{   
    uint2 texelPos = uint2(id.x, id.y);

    // uint2 dim; 
    // tex.GetDimensions(dim.x,dim.y);

    if(texelPos.x > probesBufferSize.x || texelPos.y > probesBufferSize.y)
         return;

    bool _;

    float4 val = float4(1,1,1,1) * isAtProbeBorder(texelPos,_,_);
#ifdef DEBUG_MODE
    debugTex[texelPos] = val;
#endif
    Write(probesBuffer, texelPos, probesBufferSize, val);
}

[numthreads(8,8,1)]
void mainDuplicateProbeEdges(uint3 id : SV_DispatchThreadID) 
{   
    uint2 texelPos = uint2(id.x, id.y);

    // uint2 dim;
    // tex.GetDimensions(dim.x,dim.y);
    // if(texelPos.x >= dim.x || texelPos.y >= dim.y)
    //     return;

    bool isAtBorderX, isAtBorderY;

    if(isAtProbeBorder(texelPos,isAtBorderX,isAtBorderY))
    {
        if(isAtBorderX && isAtBorderY)
        {
            int2 offsetPos = int2(texelPos.x /*minus border around tex */ + PROBE_SIDE_LENGTH * leftOrRight(texelPos.x),
                texelPos.y + PROBE_SIDE_LENGTH * leftOrRight(texelPos.y));
            float4 texelToCopy = Load(probesBuffer, offsetPos, probesBufferSize);

            Write(probesBuffer, texelPos, probesBufferSize, texelToCopy);
            #ifdef DEBUG_MODE
            debugTex[texelPos] = texelToCopy;
            #endif
            //tex[texelPos] = float4(offsetPos,1);
            return;
        }

        if(isAtBorderX)
        {
            int pos = mirrored(texelPos.y);
            int toAdd = leftOrRight(texelPos.x);
            float4 texelToCopy = Load(probesBuffer, int2(texelPos.x+toAdd,pos), probesBufferSize);
            Write(probesBuffer, texelPos, probesBufferSize, texelToCopy);
            #ifdef DEBUG_MODE
            debugTex[texelPos] = texelToCopy;
            #endif
            //tex[texelPos] = float4(pos,0.4,0.4,0);
            return;
        }

        if(isAtBorderY)
        {
            int pos = mirrored(texelPos.x);
            int toAdd = leftOrRight(texelPos.y);
            float4 texelToCopy = Load(probesBuffer, int2(pos, texelPos.y+toAdd), probesBufferSize);
            Write(probesBuffer, texelPos, probesBufferSize, texelToCopy);
            #ifdef DEBUG_MODE
            debugTex[texelPos] = texelToCopy;
            #endif
            //tex[texelPos] = float4(pos,0.4,0.4,0);
            return;
        }
        #ifdef DEBUG_MODE
        debugTex[texelPos] = float4(0,1,0,1);
        #endif
    }
}




