#pragma kernel main
#pragma multi_compile_local __ OUTPUT_IRRADIANCE
#pragma multi_compile_local __ DEBUG_MODE
#pragma multi_compile_local __ OUTPUT_IRRADIANCE DEBUG_MODE

#include "OctahedralUtilities.cginc"
#include "ShaderVariables.cginc"
#include "ShaderUtilities.cginc"
#include "ProbesUtilities.cginc"

int RAYS_PER_PROBE;

#ifdef DEBUG_MODE
RWTexture2D<float4> debugTex;
#endif

RWStructuredBuffer<float4> outputBuffer;
uint2 outputBufferSize;

#ifdef OUTPUT_IRRADIANCE
RWStructuredBuffer<float4> rayHitRadiance;
#else
RWStructuredBuffer<float4> rayHitLocations;
RWStructuredBuffer<float4> rayHitNormals;
RWStructuredBuffer<float4> rayOrigins;
#endif
RWStructuredBuffer<float4> rayDirections;
uint2 surfelsTextureSize;

float square(float f)
{
    return f * f;
}

// This is basically from the supplemental material from the paper 
// Dynamic Diffuse Global Illumination with Ray-Traced Irradiance Fields
[numthreads(8,8,1)]
void main(uint3 id : SV_DispatchThreadID)
{
#ifdef OUTPUT_IRRADIANCE
    PROBE_SIDE_LENGTH = DDGIVolumes[0].irradianceProbeSideLength;
#else
    PROBE_SIDE_LENGTH = DDGIVolumes[0].visibilityProbeSideLength;
#endif
    
    uint2 texelPos = uint2(id.x, id.y);

    float4 result = float4(0,0,0,0);

    if(texelPos.x >= outputBufferSize.x -1 || texelPos.y >= outputBufferSize.y -1 || texelPos.x < 1 || texelPos.y < 1) return;
    int relativeProbeID = texelToIndex(texelPos, outputBufferSize.x);

    if (relativeProbeID == -1) {
        Write(outputBuffer, texelPos, outputBufferSize, result);
        #ifdef DEBUG_MODE
        debugTex[texelPos] = result;
        #endif
        return;
    }

    float3 texelDirection = octDecode(normalizedOctCoord(texelPos, PROBE_SIDE_LENGTH));

    // For each ray
	for (int r = 0; r < RAYS_PER_PROBE; ++r) {
		uint2 C = float2(r, relativeProbeID);
		float3 rayDirection    = LoadBilinear(rayDirections, C, surfelsTextureSize).xyz;
#ifdef OUTPUT_IRRADIANCE
        float3  rayHitRadiance_  = LoadBilinear(rayHitRadiance, C, surfelsTextureSize).xyz * 0.95; // Energy is conserved in sampleIrradiance field. Is it needed here?
#else
		float3  rayHitLocation  = LoadBilinear(rayHitLocations, C, surfelsTextureSize).xyz;

        float3 probeLocation = LoadBilinear(rayOrigins, C, surfelsTextureSize).xyz;
        // Will be zero on a miss
		float3 rayHitNormal    = LoadBilinear(rayHitNormals, C, surfelsTextureSize).xyz;

        rayHitLocation += rayHitNormal * 0.08f;

		float rayProbeDistance = min(DDGIVolumes[0].maxDistance, distance(probeLocation, rayHitLocation));
        
        // Detect misses and force depth
        if (dot(rayHitNormal, rayHitNormal) < 1e-6)
        {
            rayProbeDistance = DDGIVolumes[0].maxDistance;
        }
#endif


#ifdef OUTPUT_IRRADIANCE
        float weight = max(0.0, dot(rayDirection, texelDirection));
#else
        float weight = pow(max(0.0, dot(rayDirection, texelDirection)), DDGIVolumes[0].depthSharpness);
#endif
        if (weight >= 1e-6) {
            // Storing the sum of the weights in alpha temporarily
#ifdef OUTPUT_IRRADIANCE
            result += float4(rayHitRadiance_ * weight, weight);
#else
            result += float4(rayProbeDistance * weight,
                square(rayProbeDistance) * weight,
                0.0,
                weight);
#endif
        }
	}
    
    float epsilon = 1e-9 * float(RAYS_PER_PROBE);
    result.xyz *= 1.0 / max(result.w, epsilon);

    float4 old = Load(outputBuffer, texelPos, outputBufferSize);
    
#ifdef OUTPUT_IRRADIANCE
    result.xyz = pow(abs(result.xyz), float3(1,1,1) * DDGIVolumes[0].invIrradianceGamma);
#endif

    float2 debugOctCoord = normalizedOctCoord(texelPos, PROBE_SIDE_LENGTH);
    float3 debugResult = 0.5f * (float3(debugOctCoord + float2(1,1), 0));

    float4 val = lerp(result, old, DDGIVolumes[0].hysteresis);
    Write(outputBuffer, texelPos, outputBufferSize, //float4(debugResult, 1));
        val);

    #ifdef DEBUG_MODE
    debugTex[texelPos] = val;
    #endif
}
