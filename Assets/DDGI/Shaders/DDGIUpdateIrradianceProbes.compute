#pragma kernel main
#pragma multi_compile __ OUTPUT_IRRADIANCE
#pragma multi_compile __ DEBUG_MODE
#pragma multi_compile __ OUTPUT_IRRADIANCE DEBUG_MODE

#include "OctahedralUtilities.cginc"
#include "ShaderVariables.cginc"
#include "ShaderUtilities.cginc"

int RAYS_PER_PROBE;

#ifdef DEBUG_MODE
RWTexture2D<float4> debugTex;
#endif

RWStructuredBuffer<float4> outputBuffer;
uint2 outputBufferSize;

#ifdef OUTPUT_IRRADIANCE
RWStructuredBuffer<float4> rayHitRadiance;
#else
RWStructuredBuffer<float4> rayHitLocations;
RWStructuredBuffer<float4> rayHitNormals;
RWStructuredBuffer<float4> rayOrigins;
#endif
RWStructuredBuffer<float4> rayDirections;
uint2 surfelsTextureSize;

int PROBE_SIDE_LENGTH;

int probeID(float2 texelXY, uint width) {
    int probeWithBorderSide = PROBE_SIDE_LENGTH + 2;
    int probesPerSide = (width - 2) / probeWithBorderSide;
    return int(texelXY.x / probeWithBorderSide) + probesPerSide * int(texelXY.y / probeWithBorderSide);
}

// Compute normalized oct coord, mapping top left of top left pixel to (-1,-1)
float2 normalizedOctCoord(uint2 fragCoord) {
    int probeWithBorderSide = PROBE_SIDE_LENGTH + 2;

    float2 octFragCoord = int2((fragCoord.x - 2) % probeWithBorderSide, (fragCoord.y - 2) % probeWithBorderSide);
    // Add back the half pixel to get pixel center normalized coordinates
    return (float2(octFragCoord) + float2(0.5f,0.5f))*(2.0f / float(PROBE_SIDE_LENGTH)) - float2(1.0f, 1.0f);
}


float square(float f)
{
    return f * f;
}

// This is basically from the supplemental material from the paper 
// Dynamic Diffuse Global Illumination with Ray-Traced Irradiance Fields
[numthreads(8,8,1)]
void main(uint3 id : SV_DispatchThreadID)
{
#ifdef OUTPUT_IRRADIANCE
    PROBE_SIDE_LENGTH = DDGIVolumes[0].irradianceProbeSideLength;
#else
    PROBE_SIDE_LENGTH = DDGIVolumes[0].visibilityProbeSideLength;
#endif
    
    float epsilon = 1e-6;
    uint2 texelPos = uint2(id.x, id.y);

    float4 result = float4(0,0,0,0);

    if(texelPos.x >= outputBufferSize.x -1 || texelPos.y >= outputBufferSize.y -1 || texelPos.x < 1 || texelPos.y < 1) return;
    int relativeProbeID = probeID(texelPos, outputBufferSize.x);

    if (relativeProbeID == -1) {
        Write(outputBuffer, texelPos, outputBufferSize, result);
        #ifdef DEBUG_MODE
        debugTex[texelPos] = result;
        #endif
        return;
    }

    float3 texelDirection = octDecode(normalizedOctCoord(texelPos));

    // For each ray
	for (int r = 0; r < RAYS_PER_PROBE; ++r) {
		uint2 C = uint2(r, relativeProbeID);
		float3 rayDirection    = Load(rayDirections, C, surfelsTextureSize).xyz;
#ifdef OUTPUT_IRRADIANCE
        float3  rayHitRadiance_  = Load(rayHitRadiance, C, surfelsTextureSize).xyz * .85; // Energy is conserved in sampleIrradiance field. Is it needed here?
#else
		float3  rayHitLocation  = Load(rayHitLocations, C, surfelsTextureSize).xyz;

        float3 probeLocation = Load(rayOrigins, C, surfelsTextureSize).xyz;
        // Will be zero on a miss
		float3 rayHitNormal    = Load(rayHitNormals, C, surfelsTextureSize).xyz;

        rayHitLocation += rayHitNormal * 0.08f;

		float rayProbeDistance = min(DDGIVolumes[0].maxDistance, length(probeLocation - rayHitLocation));
        
        // Detect misses and force depth
		if (dot(rayHitNormal, rayHitNormal) < epsilon) {
            rayProbeDistance = DDGIVolumes[0].maxDistance;
        }
#endif


#ifdef OUTPUT_IRRADIANCE
        float weight = max(0.0, dot(texelDirection, rayDirection));
#else
        float weight = pow(max(0.0, dot(texelDirection, rayDirection)), DDGIVolumes[0].depthSharpness);
#endif
        if (weight >= epsilon) {
            // Storing the sum of the weights in alpha temporarily
#ifdef OUTPUT_IRRADIANCE
            result += float4(rayHitRadiance_ * weight, weight);
#else
            result += float4(rayProbeDistance * weight,
                square(rayProbeDistance) * weight,
                0.0,
                weight);
#endif
        }
		
	}

    if (result.w > epsilon) {
        result.xyz /= result.w;
        result.w = 1.0f - DDGIVolumes[0].hysteresis;
    } // if nonzero

    float4 old = Load(outputBuffer, texelPos, outputBufferSize);
    float4 val = lerp(old, result, 1.0f - DDGIVolumes[0].hysteresis);
    Write(outputBuffer, texelPos, outputBufferSize, val);

    #ifdef DEBUG_MODE
    debugTex[texelPos] = val;
    #endif
}
