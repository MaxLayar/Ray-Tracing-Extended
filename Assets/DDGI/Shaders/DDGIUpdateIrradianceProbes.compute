#pragma kernel main
#pragma multi_compile __ OUTPUT_IRRADIANCE
#pragma multi_compile __ DEBUG_MODE
#pragma multi_compile __ OUTPUT_IRRADIANCE DEBUG_MODE

#include "OctahedralUtilities.cginc"
#include "ShaderVariables.cginc"
#include "ShaderUtilities.cginc"

int RAYS_PER_PROBE;

#ifdef DEBUG_MODE
RWTexture2D<float4> debugTex;
#endif

RWStructuredBuffer<float4> outputBuffer;
uint2 outputBufferSize;

#ifdef OUTPUT_IRRADIANCE
RWStructuredBuffer<float4> rayHitRadiance;
#else
RWStructuredBuffer<float4> rayHitLocations;
RWStructuredBuffer<float4> rayHitNormals;
RWStructuredBuffer<float4> rayOrigins;
#endif
RWStructuredBuffer<float4> rayDirections;
uint2 surfelsTextureSize;

int PROBE_SIDE_LENGTH;

int probeID(float2 texelXY, uint width) {
    int probeWithBorderSide = PROBE_SIDE_LENGTH + 2;
    int probesPerSide = width / probeWithBorderSide;
    return int(texelXY.x / probeWithBorderSide) + probesPerSide * int(texelXY.y / probeWithBorderSide);
}

// Compute normalized oct coord, mapping top left of top left pixel to (-1,-1)
float2 normalizedOctCoord(uint2 fragCoord) {
    int probeWithBorderSide = PROBE_SIDE_LENGTH + 2;

    float2 octFragCoord = int2(fragCoord.x % probeWithBorderSide, fragCoord.y % probeWithBorderSide) - int2(1, 1);
    // Add back the half pixel to get pixel center normalized coordinates
    return (octFragCoord / (float)PROBE_SIDE_LENGTH) * 2.0 - float2(1.0, 1.0);
}


float square(float f)
{
    return f * f;
}

// This is basically from the supplemental material from the paper 
// Dynamic Diffuse Global Illumination with Ray-Traced Irradiance Fields
[numthreads(8,8,1)]
void main(uint3 id : SV_DispatchThreadID)
{
#ifdef OUTPUT_IRRADIANCE
    PROBE_SIDE_LENGTH = DDGIVolumes[0].irradianceProbeSideLength;
#else
    PROBE_SIDE_LENGTH = DDGIVolumes[0].visibilityProbeSideLength;
#endif
    
    uint2 texelPos = uint2(id.x, id.y);

    float4 result = float4(0,0,0,0);

    if(texelPos.x >= outputBufferSize.x -1 || texelPos.y >= outputBufferSize.y -1 || texelPos.x < 1 || texelPos.y < 1) return;
    int relativeProbeID = probeID(texelPos, outputBufferSize.x);

    if (relativeProbeID == -1) {
        Write(outputBuffer, texelPos, outputBufferSize, result);
        #ifdef DEBUG_MODE
        debugTex[texelPos] = result;
        #endif
        return;
    }

    float3 texelDirection = octDecode(normalizedOctCoord(texelPos));

    // For each ray
	for (int r = 0; r < RAYS_PER_PROBE; ++r) {
		uint2 C = uint2(r, relativeProbeID);
		float3 rayDirection    = Load(rayDirections, C, surfelsTextureSize).xyz;
#ifdef OUTPUT_IRRADIANCE
        float3  rayHitRadiance_  = Load(rayHitRadiance, C, surfelsTextureSize).xyz; // Energy is conserved in sampleIrradiance field. Is it needed here?
#else
		float3  rayHitLocation  = Load(rayHitLocations, C, surfelsTextureSize).xyz;

        float3 probeLocation = Load(rayOrigins, C, surfelsTextureSize).xyz;
        // Will be zero on a miss
		float3 rayHitNormal    = Load(rayHitNormals, C, surfelsTextureSize).xyz;

        rayHitLocation += rayHitNormal * 0.08f;

		float rayProbeDistance = min(DDGIVolumes[0].maxDistance, length(probeLocation - rayHitLocation));
        
        // Detect misses and force depth
        if (dot(rayHitNormal, rayHitNormal) < 1e-6)
        {
            rayProbeDistance = DDGIVolumes[0].maxDistance;
        }
#endif


#ifdef OUTPUT_IRRADIANCE
        float weight = max(0.0, dot(rayDirection, texelDirection));
#else
        float weight = pow(max(0.0, dot(texelDirection, rayDirection)), DDGIVolumes[0].depthSharpness);
#endif
        //if (weight >= epsilon) {
            // Storing the sum of the weights in alpha temporarily
#ifdef OUTPUT_IRRADIANCE
            result += float4(rayHitRadiance_ * weight, weight);
#else
            result += float4(abs(rayProbeDistance) * weight,
                square(abs(rayProbeDistance)) * weight,
                0.0,
                weight);
#endif
        //}
		
	}
    
    float epsilon = 1e-9 * float(RAYS_PER_PROBE);
    result.xyz *= 1.0 / max(result.w, epsilon);
    //result.w = 1.0f - DDGIVolumes[0].hysteresis;

    float4 old = Load(outputBuffer, texelPos, outputBufferSize);
    
#ifdef OUTPUT_IRRADIANCE
    result.xyz = pow(abs(result.xyz), float3(1,1,1) * DDGIVolumes[0].invIrradianceGamma);
#endif

    float4 val = lerp(result, old, DDGIVolumes[0].hysteresis);
    Write(outputBuffer, texelPos, outputBufferSize, val);

    #ifdef DEBUG_MODE
    debugTex[texelPos] = val;
    #endif
}
