#pragma kernel main
#pragma multi_compile_local __ OUTPUT_IRRADIANCE
#pragma multi_compile_local __ DEBUG_MODE
#pragma multi_compile_local __ OUTPUT_IRRADIANCE DEBUG_MODE

#include "OctahedralUtilities.cginc"
#include "ShaderVariables.cginc"
#include "ShaderUtilities.cginc"
#include "ProbesUtilities.cginc"

int RAYS_PER_PROBE;

#ifdef DEBUG_MODE
RWTexture2D<float4> debugTex;
#endif

#ifdef OUTPUT_IRRADIANCE
RWStructuredBuffer<float4> rayHitRadiance;
#else
RWStructuredBuffer<float4> rayHitLocations;
RWStructuredBuffer<float4> rayHitNormals;
RWStructuredBuffer<float4> rayOrigins;
#endif
RWStructuredBuffer<float4> rayDirections;
uint2 surfelsTextureSize;

float square(float f)
{
    return f * f;
}

uint2 GetBufferDimensions(int probeSideLength, uint3 probeCounts)
{
    int sizeW = (probeSideLength + 2) * probeCounts.x * probeCounts.y;
    int sizeH = (probeSideLength + 2) * probeCounts.z;

    return uint2(sizeW, sizeH);
}

// This is basically from the supplemental material from the paper 
// Dynamic Diffuse Global Illumination with Ray-Traced Irradiance Fields
[numthreads(8,8,1)]
void main(uint3 id : SV_DispatchThreadID)
{
    uint2 texelPos = uint2(id.x, id.y);
#ifdef OUTPUT_IRRADIANCE
    PROBE_SIDE_LENGTH = DDGIVolumes[0].irradianceProbeSideLength;
#else
    PROBE_SIDE_LENGTH = DDGIVolumes[0].visibilityProbeSideLength;
#endif

    uint2 textureSize = GetBufferDimensions(PROBE_SIDE_LENGTH, DDGIVolumes[0].probeCounts);

    if (texelPos.x >= textureSize.x -1 || texelPos.y >= textureSize.y -1 || texelPos.x < 1 || texelPos.y < 1) return;
    int relativeProbeID = texelToIndex(texelPos, textureSize.x);

    float4 result = float4(0,0,0,0);

    if (relativeProbeID == -1) {
        Result[texelPos] = result;
        #ifdef DEBUG_MODE
        debugTex[texelPos] = result;
        #endif
        return;
    }

    int probeWithBorderSide = PROBE_SIDE_LENGTH + 2;

    // Texel relative to the corner of the probe in the final texture.
    // Every thread processes 1 texel. For the irradiance probe, the numbers work out so that one block exactly
    // processes the whole probe. For the visibility probe, there are four blocks per probe.
    int2 relativeTexelCoord = texelPos % probeWithBorderSide - 1;

    float3 texelDirection = octDecode(normalizedOctCoord(relativeTexelCoord, PROBE_SIDE_LENGTH));

    // For each ray
	for (int r = 0; r < RAYS_PER_PROBE; ++r) {
		uint2 C = uint2(r, relativeProbeID);
		float3 rayDirection    = Load(rayDirections, C, surfelsTextureSize).xyz;
#ifdef OUTPUT_IRRADIANCE
        float3  rayHitRadiance_  = Load(rayHitRadiance, C, surfelsTextureSize).xyz * 0.95; // Energy is conserved in sampleIrradiance field. Is it needed here?
#else
		float3  rayHitLocation  = Load(rayHitLocations, C, surfelsTextureSize).xyz;

        float3 probeLocation = Load(rayOrigins, C, surfelsTextureSize).xyz;
        // Will be zero on a miss
		float3 rayHitNormal    = Load(rayHitNormals, C, surfelsTextureSize).xyz;

        rayHitLocation += rayHitNormal * 0.08f;

		float rayProbeDistance = min(DDGIVolumes[0].maxDistance, distance(probeLocation, rayHitLocation));
        
        // Detect misses and force depth
        if (dot(rayHitNormal, rayHitNormal) < 1e-6)
        {
            rayProbeDistance = DDGIVolumes[0].maxDistance;
        }
#endif


#ifdef OUTPUT_IRRADIANCE
        float weight = max(0.0, dot(rayDirection, texelDirection));
#else
        float weight = pow(max(0.0, dot(rayDirection, texelDirection)), DDGIVolumes[0].depthSharpness);
#endif
        if (weight >= 1e-6) {
            // Storing the sum of the weights in alpha temporarily
#ifdef OUTPUT_IRRADIANCE
            result += float4(rayHitRadiance_ * weight, weight);
#else
            result += float4(rayProbeDistance * weight,
                square(rayProbeDistance) * weight,
                0.0,
                weight);
#endif
        }
	}
    
    float epsilon = 1e-9 * float(RAYS_PER_PROBE);
    result.xyz *= 1.0 / max(result.w, epsilon);

    #ifdef OUTPUT_IRRADIANCE
    result.xyz = pow(abs(result.xyz), float3(1,1,1) * DDGIVolumes[0].invIrradianceGamma);
    #endif

#ifdef OUTPUT_IRRADIANCE
    float4 old = irradianceTexture.SampleLevel(sampler_irradianceTexture, texelPos * DDGIVolumes[0].invIrradianceTextureSize, 0);
#else
    float4 old = visibilityTexture.SampleLevel(sampler_visibilityTexture, texelPos * DDGIVolumes[0].invVisibilityTextureSize, 0);
#endif
    
    float2 debugOctCoord = normalizedOctCoord(relativeTexelCoord, PROBE_SIDE_LENGTH);
    float3 debugResult = 0.5f * (float3(debugOctCoord + float2(1,1), 0));

    float4 val = lerp(result, old, DDGIVolumes[0].hysteresis);
    Result[texelPos] = //float4(debugResult, 1);
        val;

    #ifdef DEBUG_MODE
    debugTex[texelPos] = val;
    #endif
}
