// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

#include <UnityPBSLighting.cginc>

#include "UnityCG.cginc"
#include "SampleIrradianceField.cginc"
#include "RayTraceUtilities.cginc"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;

// Camera parameters
float4x4 _CameraLocalToWorld;
float3 ViewParams;

float4 sunColor;
float3 sunDirection;

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint2 texelPos = uint2(id.x, id.y);
    uint2 dim;
    Result.GetDimensions(dim.x, dim.y);

    float2 uv = float2((float) texelPos.x/dim.x, (float) texelPos.y/dim.y);
    float3 viewPointLocal = float3(uv - 0.5, 1) * ViewParams;
    float3 viewPoint = mul(_CameraLocalToWorld, float4(viewPointLocal, 1));

    Ray ray;
    ray.origin = _WorldSpaceCameraPos;
    ray.direction = normalize(viewPoint - ray.origin);
    ray.tMin = 0.01;
    ray.tMax = 1000.0;

    HitInfo info;
    if (TraceRay(ray, info))
    {
        float3 viewVec = normalize(_WorldSpaceCameraPos - info.hitPoint);

        // float4 irradiance = float4(sampleIrradiance(DDGIVolumes,
        //         info.hitPoint,                       //wsPosition
        //         info.normal * 0.2 + viewVec * 0.8,   //offsetPos
        //         -info.normal,                         //sampleDirection
        //         _WorldSpaceCameraPos,                //cameraPos
        //         true, false, -1), 1);
        Result[id.xy] = ComputeShadingAt(info, viewVec, sunDirection, sunColor);
    }
    else
        Result[id.xy] = float4(0,0,.1,1);
}

// sampleIrradiance(ddgiVolumeArray,
//         surfel.position,
//         surfel.shadingNormal * 0.2 + w_o * 0.8,
//         surfel.shadingNormal,
//         cameraPos)
