// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel main

#include "RayTraceUtilities.cginc"
#include "RandomUtilities.cginc"

#define M_PI 3.1415926535897932384626433832795

StructuredBuffer<float3> ProbesPositions;

RWTexture2D<float4> rayDirections;
RWTexture2D<float4> rayHitLocations;
RWTexture2D<float4> rayHitRadiance;
RWTexture2D<float4> rayHitNormals;
RWTexture2D<float4> rayOrigins;

float4x4 randomOrientation;
float4 sunColor;
float3 sunDirection;
float energyConservation = 0.95;

//DEBUG
RWTexture2D<float4> Result;
int Frame;

// This is basically from the supplemental material from the paper 
// Dynamic Diffuse Global Illumination with Ray-Traced Irradiance Fields

/**  Generate a spherical fibonacci point

    http://lgdv.cs.fau.de/publications/publication/Pub.2015.tech.IMMD.IMMD9.spheri/

    To generate a nearly uniform point distribution on the unit sphere of size N, do
    for (float i = 0.0; i < N; i += 1.0) {
        float3 point = sphericalFibonacci(i,N);
    }

    The points go from z = +1 down to z = -1 in a spiral. To generate samples on the +z hemisphere,
    just stop before i > N/2.

*/
float3 sphericalFibonacci(float i, float n) {
    const float PHI = sqrt(5) * 0.5 + 0.5;
#   define madfrac(A, B) ((A)*(B)-floor((A)*(B)))
    float phi = 2.0 * M_PI * madfrac(i, PHI - 1);
    float cosTheta = 1.0 - (2.0 * i + 1.0) * (1.0 / n);
    float sinTheta = sqrt(saturate(1.0 - cosTheta * cosTheta));

    return float3(
        cos(phi) * sinTheta,
        sin(phi) * sinTheta,
        cosTheta);

#   undef madfrac
}



[numthreads(8,8,1)]
void main(uint3 id : SV_DispatchThreadID)
{
    uint2 texelPos = uint2(
        //groupId.x * 8 + threadInGroup.x,
        //groupId.y * 8 + threadInGroup.y
        id.x,
        id.y
    );

    // uint2 dim;
    // rayDirections.GetDimensions(dim.x, dim.y);
    // if(texelPos.x >= dim.x || texelPos.y >= dim.y) return;

    Ray ray;
    ray.direction = normalize(float3(mul(sphericalFibonacci((float) texelPos.x, (float) NumRaysPerProbe), (float3x3) randomOrientation))); //rayId = texelPos.x
    ray.origin = ProbesPositions[texelPos.y]; //probeId = texelPos.y
    ray.tMin = 0.01;
    ray.tMax = 20.0;

    HitInfo info;
    float4 allLight = float4(0,0,0,0);
    int lit = 0;
    if (TraceRay(ray, info))
    {
        float3 viewVec = normalize(ray.origin.xyz-info.hitPoint);
        //float3 indirectL = SampleIrradianceField(info.hitPoint, info.normal, energyConservation, viewVec); 
        Ray shadowRay;
        shadowRay.direction = -sunDirection;
        shadowRay.origin = info.hitPoint;
        shadowRay.tMin = 0.01;
        shadowRay.tMax = 20.0;
        lit = !TraceRaySimple(shadowRay);//sHit ? 0 : 1;
        float4 directL = max(dot(-sunDirection, info.normal),0.0) * sunColor * lit;
        allLight = //(directL + indirectL) * info.color;
            directL * info.material.colour; //Broken, colour = 0;
    }
    Result[texelPos] = lit ? float4(1,1,1,1) : float4(0,0,0,0);

    float d = max(dot(-sunDirection,info.normal),0);
    rayDirections[texelPos] = float4(ray.direction,0);
    rayHitLocations[texelPos] = info.didHit ? float4(info.hitPoint,0) : float4(0,0,0,0);
    rayHitRadiance[texelPos] = allLight;
    rayHitNormals[texelPos] = info.didHit ? float4(info.normal,0) : float4(0,0,0,0);
    rayOrigins[texelPos] = float4(ray.origin, info.dst);
}